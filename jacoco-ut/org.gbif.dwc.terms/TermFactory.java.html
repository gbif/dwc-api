<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TermFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Darwin Core API</a> &gt; <a href="index.source.html" class="el_package">org.gbif.dwc.terms</a> &gt; <span class="el_source">TermFactory.java</span></div><h1>TermFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2021 Global Biodiversity Information Facility (GBIF)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gbif.dwc.terms;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Simple, threadsafe factory for terms that knows about all ConceptTerms of this library and keeps singletons for
 * all unknown Term instances.
 */
public class TermFactory {

<span class="fc" id="L34">  private static final Logger LOG = LoggerFactory.getLogger(TermFactory.class);</span>
<span class="fc" id="L35">  private static final Pattern NON_ALPHA_NUM_PATTERN = Pattern.compile(&quot;[^a-zA-Z0-9#-]+&quot;);</span>
  private static TermFactory singleton;
<span class="fc" id="L37">  private static boolean initialized = false;</span>
<span class="fc" id="L38">  private static final Object LOCK = new Object();</span>

<span class="fc" id="L40">  private final Map&lt;String, Term&gt; terms = new HashMap&lt;String, Term&gt;();</span>
<span class="fc" id="L41">  private final Map&lt;String, Term&gt; classTerms = new HashMap&lt;String, Term&gt;();</span>
<span class="fc" id="L42">  private final Set&lt;Class&lt;? extends Enum&gt;&gt; registeredEnumClasses = new HashSet&lt;&gt;();</span>

  public static TermFactory instance() {
<span class="fc bfc" id="L45" title="All 2 branches covered.">    if (initialized) {</span>
<span class="fc" id="L46">      return singleton;</span>
    }

<span class="fc" id="L49">    synchronized (LOCK) {</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">      if (singleton == null) {</span>
<span class="fc" id="L51">        LOG.debug(&quot;Building new TermFactory instance&quot;);</span>
<span class="fc" id="L52">        singleton = new TermFactory();</span>
<span class="fc" id="L53">        singleton.loadKnownTerms();</span>
<span class="fc" id="L54">        initialized = true;</span>
      }
<span class="fc" id="L56">    }</span>

<span class="fc" id="L58">    return singleton;</span>
  }

<span class="fc" id="L61">  private TermFactory() {</span>
<span class="fc" id="L62">  }</span>

  private void loadKnownTerms() {
<span class="fc" id="L65">    registerTermEnum(DwcTerm.class);</span>
<span class="fc" id="L66">    registerTermEnum(DcTerm.class, &quot;dct&quot;);</span>
<span class="fc" id="L67">    registerTermEnum(GbifTerm.class);</span>
<span class="fc" id="L68">    registerTermEnum(GbifInternalTerm.class);</span>
<span class="fc" id="L69">    registerTermEnum(IucnTerm.class);</span>
<span class="fc" id="L70">    registerTermEnum(DcElement.class);</span>
<span class="fc" id="L71">    registerTermEnum(AcefTerm.class, &quot;http://rs.col.plus/terms/acef/&quot;);</span>
<span class="fc" id="L72">    registerTermEnum(PlaziTerm.class);</span>
<span class="fc" id="L73">    registerTermEnum(GadmTerm.class);</span>
<span class="fc" id="L74">    registerTermEnum(DwcaTerm.class);</span>

    // Audubon core
<span class="fc" id="L77">    registerTermEnum(AcTerm.class);</span>
<span class="fc" id="L78">    registerTermEnum(ExifTerm.class);</span>
<span class="fc" id="L79">    registerTermEnum(IptcTerm.class);</span>
<span class="fc" id="L80">    registerTermEnum(PhotoshopTerm.class);</span>
<span class="fc" id="L81">    registerTermEnum(XmpTerm.class, &quot;adobe&quot;);</span>
<span class="fc" id="L82">    registerTermEnum(XmpRightsTerm.class, &quot;xmp&quot;, &quot;adobe&quot;); // the same as above, but luckily different simple term names</span>

    // DWCA extensions
<span class="fc" id="L85">    registerTermEnum(ChronoTerm.class);</span>
<span class="fc" id="L86">    registerTermEnum(GbifDnaTerm.class);</span>
<span class="fc" id="L87">    registerTermEnum(GbifMiqeTerm.class);</span>
<span class="fc" id="L88">    registerTermEnum(GermplasmTerm.class);</span>
<span class="fc" id="L89">    registerTermEnum(GgbnTerm.class);</span>
<span class="fc" id="L90">    registerTermEnum(MixsTerm.class);</span>
<span class="fc" id="L91">    registerTermEnum(ObisTerm.class);</span>
<span class="fc" id="L92">    registerTermEnum(Wgs84GeoPositioningTerm.class);</span>

<span class="fc" id="L94">    registerQualifiedTermEnum(DwcaTerm.class);</span>
<span class="fc" id="L95">    addTerm(BibTexTerm.CLASS_TERM);</span>
<span class="fc" id="L96">  }</span>

  /**
   * @return the set of term enum classes that have been registered with this TermFactory
   */
  public Set&lt;Class&lt;? extends Enum&gt;&gt; listRegisteredTermEnums() {
<span class="nc" id="L102">    return Collections.unmodifiableSet(registeredEnumClasses);</span>
  }

  public void registerTerm(Term term) {
<span class="nc" id="L106">    addTerm(term);</span>
<span class="nc" id="L107">  }</span>

  public void registerTerm(UnknownTerm term) {
<span class="nc" id="L110">    addTerm(term.qualifiedName(), term);</span>
<span class="nc" id="L111">  }</span>

  /**
   * Registers all terms from a term enumeration.
   * If the same class is registered again it will be silently ignored.
   *
   * @param altPrefixes alternative prefixes to be used to register simple prefixed term names
   */
  public synchronized &lt;T extends Enum &amp; Term &amp; AlternativeNames&gt; void registerTermEnum(Class&lt;T&gt; termClass, String ... altPrefixes) {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">    if (registeredEnumClasses.contains(termClass)) {</span>
<span class="nc" id="L121">      LOG.debug(&quot;{} is already registered&quot;, termClass);</span>
    } else {
<span class="fc" id="L123">      registeredEnumClasses.add(termClass);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">      for (T term : termClass.getEnumConstants()) {</span>
        // add regular term representations (simple, prefixed &amp; qualified)
<span class="fc" id="L126">        addTerm(term, altPrefixes);</span>
        // add alternatives
<span class="fc bfc" id="L128" title="All 2 branches covered.">        for (String alt : term.alternativeNames()) {</span>
<span class="fc" id="L129">          addTerm(alt, term);</span>
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">          if (!alt.startsWith(&quot;http&quot;) &amp;&amp; !alt.contains(&quot;:&quot;)) {</span>
<span class="fc" id="L131">            addTerm(term.prefix() + &quot;:&quot; + alt, term);</span>
<span class="fc" id="L132">            addTerm(term.namespace().resolve(alt).toString(), term);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">            for (String pre : altPrefixes) {</span>
<span class="fc" id="L134">              addTerm(pre + &quot;:&quot; + alt, term);</span>
            }
          }
        }
      }
    }
<span class="fc" id="L140">  }</span>

  /**
   * Registers all terms from a new term enumeration, but only adds their qualified and prefixed names.
   * This is to avoid clashes with other usually more important terms that should be known by their simple name.
   */
  public &lt;T extends Enum &amp; Term&gt; void registerQualifiedTermEnum(Class&lt;T&gt; termClass) {
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">    if (registeredEnumClasses.contains(termClass)) {</span>
<span class="fc" id="L148">      LOG.debug(&quot;{} is already registered&quot;, termClass);</span>
    } else {
<span class="nc" id="L150">      registeredEnumClasses.add(termClass);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">      for (T term : termClass.getEnumConstants()) {</span>
        // add only the prefixed and qualified representation to avoid clashes
<span class="nc" id="L153">        addTerm(term.prefixedName(), term);</span>
<span class="nc" id="L154">        addTerm(term.qualifiedName(), term);</span>
      }
    }
<span class="fc" id="L157">  }</span>

  private void addTerm(Term term, String ... altPrefixes) {
<span class="fc" id="L160">    addTerm(term.simpleName(), term);</span>
<span class="fc" id="L161">    addTerm(term.prefixedName(), term);</span>
<span class="fc" id="L162">    addTerm(term.qualifiedName(), term);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">    for (String pre : altPrefixes) {</span>
<span class="fc" id="L164">      addTerm(pre + &quot;:&quot; + term.simpleName(), term);</span>
    }
<span class="fc" id="L166">  }</span>

  private void addTerm(String key, Term term) {
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">    if (key == null || key.trim().isEmpty()) {</span>
<span class="nc" id="L170">      return;</span>
    }

    // keep class terms distinct
<span class="fc" id="L174">    Map&lt;String, Term&gt; map = termMap(term.isClass());</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">    if (map.containsKey(key)) {</span>
<span class="fc" id="L176">      Term t1 = map.get(key);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (!t1.equals(term)) {</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        LOG.info(&quot;{} terms {} and {} are both known as \&quot;{}\&quot;. Keeping only earlier {}&quot;, term.isClass() ? &quot;Class&quot; : &quot;Property&quot;, map.get(key), term, key, map.get(key));</span>
      }
<span class="fc" id="L180">    } else {</span>
<span class="fc" id="L181">      map.put(key, term);</span>
      // also add a normalised version
<span class="fc" id="L183">      key = normaliseTerm(key);</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">      if (!map.containsKey(key)) {</span>
<span class="fc" id="L185">        map.put(key, term);</span>
      }
    }
<span class="fc" id="L188">  }</span>

  private Map&lt;String, Term&gt; termMap(boolean isClass) {
<span class="fc bfc" id="L191" title="All 2 branches covered.">    return isClass ? classTerms : terms;</span>
  }

  /**
   * @return a purely alphanumerical, lower cased term with all other characters replaced
   */
  public static String normaliseTerm(String term) {
<span class="fc" id="L198">    String x = NON_ALPHA_NUM_PATTERN.matcher(term).replaceAll(&quot;&quot;);</span>
    // remove http(s)
<span class="fc" id="L200">    x = x.replaceFirst(&quot;^https?&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">    if (x.isEmpty()) {</span>
<span class="nc" id="L202">      return &quot;&quot;;</span>
    }
<span class="fc" id="L204">    return x.toLowerCase();</span>
  }

  /**
   * This is the main method to get a term from the factory searching both for property or class terms.
   * It will lookup matching terms applying some normalization and known synonyms first.
   * In case of ambiguous terms Class terms will be preferred.
   *
   * If nothing matches the factory creates a new UnknownTerm property instance and keeps it for further requests so that
   * all terms with the same qualified name return a single UnknownTerm instance.
   *
   * For clearly bad term names an IllegalArgumentException is thrown.
   * For example in the case of a simple name containing whitespace like &quot;hello tom&quot;.
   * Ideally the term names to be looked up should be full URIs, but simple names made up of alphanumerics and dashes
   * will also work fine. Unknown simple names will be put into the namespace http://unknown.org when a new UnknownTerm
   * instance is created.
   */
  public Term findTerm(final String termName) throws IllegalArgumentException {
    // First try an exact match.
<span class="fc bfc" id="L223" title="All 2 branches covered.">    if (terms.containsKey(termName)) {</span>
<span class="fc" id="L224">      return terms.get(termName);</span>
    }

    // Try class term
<span class="fc" id="L228">    Term t = findTermOnly(termName, true);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (t == null) {</span>
      // Try property term
<span class="fc" id="L231">      t = findTermOnly(termName, false);</span>
    }
    // create new term if needed
<span class="fc bfc" id="L234" title="All 2 branches covered.">    if (t == null) {</span>
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">      if (termName.startsWith(BibTexTerm.NS) || termName.startsWith(BibTexTerm.PREFIX+&quot;:&quot;)) {</span>
<span class="fc" id="L236">        t = createBibtexTerm(termName, termName.startsWith(BibTexTerm.NS));</span>
      } else {
<span class="fc" id="L238">        t = createUnknownTerm(termName, false);</span>
      }
    }
<span class="fc" id="L241">    return t;</span>
  }

  /**
   * This method works just as findTerm(final String termName) but restricts
   * the results to just property terms.
   */
  public Term findPropertyTerm(final String termName) throws IllegalArgumentException {
<span class="fc" id="L249">    return findTerm(termName, false);</span>
  }

  /**
   * This method works just as findTerm(final String termName) but restricts
   * the results to just class terms.
   */
  public Term findClassTerm(final String termName) throws IllegalArgumentException {
<span class="fc" id="L257">    return findTerm(termName, true);</span>
  }

  /**
   * This method works just as findTerm(final String termName) but restricts
   * the results to just property or class terms.
   */
  public Term findTerm(final String termName, boolean isClassTerm) throws IllegalArgumentException {
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">    if (termName == null || termName.trim().isEmpty()) {</span>
<span class="nc" id="L266">      return null;</span>
    }

<span class="fc" id="L269">    Term t = findTermOnly(termName, isClassTerm);</span>
    // create new term if needed
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">    if (t == null) {</span>
<span class="nc" id="L272">      t = createUnknownTerm(termName, isClassTerm);</span>
    }
<span class="fc" id="L274">    return t;</span>
  }

  /**
   * Does not create Unknown terms
   */
  private Term findTermOnly(final String termName, boolean isClassTerm) throws IllegalArgumentException {
<span class="pc bpc" id="L281" title="2 of 4 branches missed.">    if (termName == null || termName.trim().isEmpty()) {</span>
<span class="nc" id="L282">      return null;</span>
    }

<span class="fc" id="L285">    Map&lt;String, Term&gt; map = termMap(isClassTerm);</span>
    // first try term just as it is
<span class="fc bfc" id="L287" title="All 2 branches covered.">    if (map.containsKey(termName)) {</span>
<span class="fc" id="L288">      return map.get(termName);</span>
    }

    // try normalised term otherwise
<span class="fc bfc" id="L292" title="All 2 branches covered.">    if (map.containsKey(normaliseTerm(termName))) {</span>
<span class="fc" id="L293">      return map.get(normaliseTerm(termName));</span>
    }
<span class="fc" id="L295">    return null;</span>
  }

  private Term createUnknownTerm(String termName, boolean isClassTerm) {
    // create new term instance
<span class="fc" id="L300">    Term term = UnknownTerm.build(termName, isClassTerm);</span>
<span class="fc" id="L301">    addTerm(termName, term);</span>
<span class="fc" id="L302">    addTerm(term.qualifiedName(), term);</span>
<span class="fc" id="L303">    return term;</span>
  }

  private Term createBibtexTerm(String termName, boolean qualified) {
    // create new term instance
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">    Term term = qualified ? BibTexTerm.buildFromURI(termName) : BibTexTerm.buildFromPrefix(termName);</span>
<span class="fc" id="L309">    addTerm(term.qualifiedName(), term);</span>
<span class="fc" id="L310">    addTerm(term.prefixedName(), term);</span>
<span class="fc" id="L311">    return term;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>